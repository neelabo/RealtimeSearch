using Microsoft.CodeAnalysis;
using NeeLaboratory.SourceGenerator.Tools;
using System;

namespace NeeLaboratory.SourceGenerator;

[Generator]
public sealed class SubscribeEventGenerator : IIncrementalGenerator
{
    private static string _generatorNamespace = "NeeLaboratory.Generators";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("SubscribableAttribute.g.cs", $$"""
            using System;
            namespace {{_generatorNamespace}};
            
            [AttributeUsage(AttributeTargets.Event, AllowMultiple = false, Inherited = false)]
            internal sealed class SubscribableAttribute : Attribute
            {
            }
            """);
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{_generatorNamespace}.SubscribableAttribute",
            static (node, token) => true,
            static (context, token) => context);

        context.RegisterSourceOutput(source, Emit);
    }

    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var ts = (IEventSymbol)source.TargetSymbol;

        string nameSpace = ts.ContainingNamespace?.ToString();
        string className = ts.ContainingSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        string eventName = ts.Name;
        string eventTypeName = ts.Type.ToDisplayString().TrimEnd('?');
        string eventAccessModifiers = ts.IsStatic ? "public static" : "public";

        bool isInterface = ((ITypeSymbol)ts.ContainingSymbol).TypeKind == TypeKind.Interface;

        var ns = ts.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {ts.ContainingNamespace};";

        var fullType = source.TargetSymbol.ToString();

        string code;
        if (isInterface)
        {
            code = $$"""
                // <auto-generated/>
                using System;

                {{ns}}

                partial interface {{className}}
                {
                    IDisposable Subscribe{{eventName}}({{eventTypeName}} handler);
                }
                """;
        }
        else
        {
            code = $$"""
                // <auto-generated/>
                using System;
                using NeeLaboratory.ComponentModel;

                {{ns}}

                partial class {{className}}
                {
                    {{eventAccessModifiers}} IDisposable Subscribe{{eventName}}({{eventTypeName}} handler)
                    {
                        {{eventName}} += handler;
                        return new AnonymousDisposable(() => {{eventName}} -= handler);
                    }
                }
                """;
        }
        context.AddSource(PathTools.ReplaceInvalidFileNameChars($"{fullType}.SubscribeEventGenerator.g.cs"), code);
    }
}